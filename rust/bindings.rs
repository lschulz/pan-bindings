/* automatically generated by rust-bindgen 0.65.1 */

#[derive(PartialEq, Copy, Clone, Hash, Debug, Default)]
#[repr(C)]
pub struct __BindgenComplex<T> {
    pub re: T,
    pub im: T,
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _ISOC95_SOURCE: u32 = 1;
pub const _ISOC99_SOURCE: u32 = 1;
pub const _ISOC11_SOURCE: u32 = 1;
pub const _ISOC2X_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _XOPEN_SOURCE: u32 = 700;
pub const _XOPEN_SOURCE_EXTENDED: u32 = 1;
pub const _LARGEFILE64_SOURCE: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const _DYNAMIC_STACK_SIZE_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_ISOCXX11: u32 = 1;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const __USE_XOPEN: u32 = 1;
pub const __USE_XOPEN_EXTENDED: u32 = 1;
pub const __USE_UNIX98: u32 = 1;
pub const _LARGEFILE_SOURCE: u32 = 1;
pub const __USE_XOPEN2K8XSI: u32 = 1;
pub const __USE_XOPEN2KXSI: u32 = 1;
pub const __USE_LARGEFILE: u32 = 1;
pub const __USE_LARGEFILE64: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_DYNAMIC_STACK_SIZE: u32 = 1;
pub const __USE_GNU: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 1;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 0;
pub const __GLIBC_USE_LIB_EXT2: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const INT8_WIDTH: u32 = 8;
pub const UINT8_WIDTH: u32 = 8;
pub const INT16_WIDTH: u32 = 16;
pub const UINT16_WIDTH: u32 = 16;
pub const INT32_WIDTH: u32 = 32;
pub const UINT32_WIDTH: u32 = 32;
pub const INT64_WIDTH: u32 = 64;
pub const UINT64_WIDTH: u32 = 64;
pub const INT_LEAST8_WIDTH: u32 = 8;
pub const UINT_LEAST8_WIDTH: u32 = 8;
pub const INT_LEAST16_WIDTH: u32 = 16;
pub const UINT_LEAST16_WIDTH: u32 = 16;
pub const INT_LEAST32_WIDTH: u32 = 32;
pub const UINT_LEAST32_WIDTH: u32 = 32;
pub const INT_LEAST64_WIDTH: u32 = 64;
pub const UINT_LEAST64_WIDTH: u32 = 64;
pub const INT_FAST8_WIDTH: u32 = 8;
pub const UINT_FAST8_WIDTH: u32 = 8;
pub const INT_FAST16_WIDTH: u32 = 64;
pub const UINT_FAST16_WIDTH: u32 = 64;
pub const INT_FAST32_WIDTH: u32 = 64;
pub const UINT_FAST32_WIDTH: u32 = 64;
pub const INT_FAST64_WIDTH: u32 = 64;
pub const UINT_FAST64_WIDTH: u32 = 64;
pub const INTPTR_WIDTH: u32 = 64;
pub const UINTPTR_WIDTH: u32 = 64;
pub const INTMAX_WIDTH: u32 = 64;
pub const UINTMAX_WIDTH: u32 = 64;
pub const PTRDIFF_WIDTH: u32 = 64;
pub const SIG_ATOMIC_WIDTH: u32 = 32;
pub const SIZE_WIDTH: u32 = 64;
pub const WCHAR_WIDTH: u32 = 32;
pub const WINT_WIDTH: u32 = 32;
pub const PAN_INVALID_HANDLE: u32 = 0;
pub const PAN_ERR_OK: u32 = 0;
pub const PAN_ERR_FAILED: u32 = 1;
pub const PAN_ERR_DEADLINE: u32 = 2;
pub const PAN_ERR_NO_PATH: u32 = 3;
pub const PAN_ERR_ADDR_SYNTAX: u32 = 4;
pub const PAN_ERR_ADDR_RESOLUTION: u32 = 5;
pub const PAN_ERR_WOULDBLOCK: u32 = 6;
pub const PAN_ERR_HOSTNOTFOUND: u32 = 7;
pub const PAN_STREAM_HDR_SIZE: u32 = 4;
pub const PAN_ADDR_HDR_SIZE: u32 = 32;
pub const _GLIBCXX_CSTDINT: u32 = 1;
pub const _GLIBCXX_CXX_CONFIG_H: u32 = 1;
pub const _GLIBCXX_RELEASE: u32 = 13;
pub const __GLIBCXX__: u32 = 20230711;
pub const _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY: u32 = 1;
pub const _GLIBCXX_USE_DEPRECATED: u32 = 1;
pub const _GLIBCXX_EXTERN_TEMPLATE: u32 = 1;
pub const _GLIBCXX_USE_DUAL_ABI: u32 = 1;
pub const _GLIBCXX_USE_CXX11_ABI: u32 = 1;
pub const _GLIBCXX_INLINE_VERSION: u32 = 0;
pub const _GLIBCXX_HAVE_IS_CONSTANT_EVALUATED: u32 = 1;
pub const _GLIBCXX_VERBOSE_ASSERT: u32 = 1;
pub const _GLIBCXX_USE_ALLOCATOR_NEW: u32 = 1;
pub const _GLIBCXX_OS_DEFINES: u32 = 1;
pub const __NO_CTYPE: u32 = 1;
pub const _GLIBCXX_HAVE_FLOAT128_MATH: u32 = 1;
pub const _GLIBCXX_GTHREAD_USE_WEAK: u32 = 0;
pub const _GLIBCXX_CPU_DEFINES: u32 = 1;
pub const _GLIBCXX_FAST_MATH: u32 = 0;
pub const _GLIBCXX_USE_FLOAT128: u32 = 1;
pub const _GLIBCXX_FLOAT_IS_IEEE_BINARY32: u32 = 1;
pub const _GLIBCXX_DOUBLE_IS_IEEE_BINARY64: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_HAS_UNIQ_OBJ_REP: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_IS_AGGREGATE: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_IS_SAME: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_LAUNDER: u32 = 1;
pub const _GLIBCXX_HAVE_ACOSF: u32 = 1;
pub const _GLIBCXX_HAVE_ACOSL: u32 = 1;
pub const _GLIBCXX_HAVE_ALIGNED_ALLOC: u32 = 1;
pub const _GLIBCXX_HAVE_ARPA_INET_H: u32 = 1;
pub const _GLIBCXX_HAVE_ASINF: u32 = 1;
pub const _GLIBCXX_HAVE_ASINL: u32 = 1;
pub const _GLIBCXX_HAVE_AS_SYMVER_DIRECTIVE: u32 = 1;
pub const _GLIBCXX_HAVE_ATAN2F: u32 = 1;
pub const _GLIBCXX_HAVE_ATAN2L: u32 = 1;
pub const _GLIBCXX_HAVE_ATANF: u32 = 1;
pub const _GLIBCXX_HAVE_ATANL: u32 = 1;
pub const _GLIBCXX_HAVE_ATOMIC_LOCK_POLICY: u32 = 1;
pub const _GLIBCXX_HAVE_AT_QUICK_EXIT: u32 = 1;
pub const _GLIBCXX_HAVE_CEILF: u32 = 1;
pub const _GLIBCXX_HAVE_CEILL: u32 = 1;
pub const _GLIBCXX_HAVE_COMPLEX_H: u32 = 1;
pub const _GLIBCXX_HAVE_COSF: u32 = 1;
pub const _GLIBCXX_HAVE_COSHF: u32 = 1;
pub const _GLIBCXX_HAVE_COSHL: u32 = 1;
pub const _GLIBCXX_HAVE_COSL: u32 = 1;
pub const _GLIBCXX_HAVE_DECL_STRNLEN: u32 = 1;
pub const _GLIBCXX_HAVE_DIRENT_H: u32 = 1;
pub const _GLIBCXX_HAVE_DIRFD: u32 = 1;
pub const _GLIBCXX_HAVE_DLFCN_H: u32 = 1;
pub const _GLIBCXX_HAVE_ENDIAN_H: u32 = 1;
pub const _GLIBCXX_HAVE_EXCEPTION_PTR_SINCE_GCC46: u32 = 1;
pub const _GLIBCXX_HAVE_EXECINFO_H: u32 = 1;
pub const _GLIBCXX_HAVE_EXPF: u32 = 1;
pub const _GLIBCXX_HAVE_EXPL: u32 = 1;
pub const _GLIBCXX_HAVE_FABSF: u32 = 1;
pub const _GLIBCXX_HAVE_FABSL: u32 = 1;
pub const _GLIBCXX_HAVE_FCNTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_FDOPENDIR: u32 = 1;
pub const _GLIBCXX_HAVE_FENV_H: u32 = 1;
pub const _GLIBCXX_HAVE_FINITE: u32 = 1;
pub const _GLIBCXX_HAVE_FINITEF: u32 = 1;
pub const _GLIBCXX_HAVE_FINITEL: u32 = 1;
pub const _GLIBCXX_HAVE_FLOAT_H: u32 = 1;
pub const _GLIBCXX_HAVE_FLOORF: u32 = 1;
pub const _GLIBCXX_HAVE_FLOORL: u32 = 1;
pub const _GLIBCXX_HAVE_FMODF: u32 = 1;
pub const _GLIBCXX_HAVE_FMODL: u32 = 1;
pub const _GLIBCXX_HAVE_FREXPF: u32 = 1;
pub const _GLIBCXX_HAVE_FREXPL: u32 = 1;
pub const _GLIBCXX_HAVE_GETENTROPY: u32 = 1;
pub const _GLIBCXX_HAVE_GETIPINFO: u32 = 1;
pub const _GLIBCXX_HAVE_GETS: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOT: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOTF: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOTL: u32 = 1;
pub const _GLIBCXX_HAVE_ICONV: u32 = 1;
pub const _GLIBCXX_HAVE_INTTYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_ISINFF: u32 = 1;
pub const _GLIBCXX_HAVE_ISINFL: u32 = 1;
pub const _GLIBCXX_HAVE_ISNANF: u32 = 1;
pub const _GLIBCXX_HAVE_ISNANL: u32 = 1;
pub const _GLIBCXX_HAVE_ISWBLANK: u32 = 1;
pub const _GLIBCXX_HAVE_LC_MESSAGES: u32 = 1;
pub const _GLIBCXX_HAVE_LDEXPF: u32 = 1;
pub const _GLIBCXX_HAVE_LDEXPL: u32 = 1;
pub const _GLIBCXX_HAVE_LIBINTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_AS: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_DATA: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_FSIZE: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_RSS: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_VMEM: u32 = 0;
pub const _GLIBCXX_HAVE_LINK: u32 = 1;
pub const _GLIBCXX_HAVE_LINK_H: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_FUTEX: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_RANDOM_H: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_TYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_LOCALE_H: u32 = 1;
pub const _GLIBCXX_HAVE_LOG10F: u32 = 1;
pub const _GLIBCXX_HAVE_LOG10L: u32 = 1;
pub const _GLIBCXX_HAVE_LOGF: u32 = 1;
pub const _GLIBCXX_HAVE_LOGL: u32 = 1;
pub const _GLIBCXX_HAVE_MBSTATE_T: u32 = 1;
pub const _GLIBCXX_HAVE_MEMALIGN: u32 = 1;
pub const _GLIBCXX_HAVE_MEMORY_H: u32 = 1;
pub const _GLIBCXX_HAVE_MODF: u32 = 1;
pub const _GLIBCXX_HAVE_MODFF: u32 = 1;
pub const _GLIBCXX_HAVE_MODFL: u32 = 1;
pub const _GLIBCXX_HAVE_NETDB_H: u32 = 1;
pub const _GLIBCXX_HAVE_NETINET_IN_H: u32 = 1;
pub const _GLIBCXX_HAVE_NETINET_TCP_H: u32 = 1;
pub const _GLIBCXX_HAVE_OPENAT: u32 = 1;
pub const _GLIBCXX_HAVE_POLL: u32 = 1;
pub const _GLIBCXX_HAVE_POLL_H: u32 = 1;
pub const _GLIBCXX_HAVE_POSIX_MEMALIGN: u32 = 1;
pub const _GLIBCXX_HAVE_POSIX_SEMAPHORE: u32 = 1;
pub const _GLIBCXX_HAVE_POWF: u32 = 1;
pub const _GLIBCXX_HAVE_POWL: u32 = 1;
pub const _GLIBCXX_HAVE_QUICK_EXIT: u32 = 1;
pub const _GLIBCXX_HAVE_READLINK: u32 = 1;
pub const _GLIBCXX_HAVE_SECURE_GETENV: u32 = 1;
pub const _GLIBCXX_HAVE_SETENV: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOS: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOSF: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOSL: u32 = 1;
pub const _GLIBCXX_HAVE_SINF: u32 = 1;
pub const _GLIBCXX_HAVE_SINHF: u32 = 1;
pub const _GLIBCXX_HAVE_SINHL: u32 = 1;
pub const _GLIBCXX_HAVE_SINL: u32 = 1;
pub const _GLIBCXX_HAVE_SOCKATMARK: u32 = 1;
pub const _GLIBCXX_HAVE_SQRTF: u32 = 1;
pub const _GLIBCXX_HAVE_SQRTL: u32 = 1;
pub const _GLIBCXX_HAVE_STDALIGN_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDBOOL_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDINT_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDLIB_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRERROR_L: u32 = 1;
pub const _GLIBCXX_HAVE_STRERROR_R: u32 = 1;
pub const _GLIBCXX_HAVE_STRINGS_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRING_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRTOF: u32 = 1;
pub const _GLIBCXX_HAVE_STRTOLD: u32 = 1;
pub const _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE: u32 = 1;
pub const _GLIBCXX_HAVE_STRXFRM_L: u32 = 1;
pub const _GLIBCXX_HAVE_SYMLINK: u32 = 1;
pub const _GLIBCXX_HAVE_SYMVER_SYMBOL_RENAMING_RUNTIME_SUPPORT: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_IOCTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_IPC_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_PARAM_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_RESOURCE_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SDT_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SEM_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SOCKET_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_STATVFS_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_STAT_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SYSINFO_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_TIME_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_TYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_UIO_H: u32 = 1;
pub const _GLIBCXX_HAVE_S_ISREG: u32 = 1;
pub const _GLIBCXX_HAVE_TANF: u32 = 1;
pub const _GLIBCXX_HAVE_TANHF: u32 = 1;
pub const _GLIBCXX_HAVE_TANHL: u32 = 1;
pub const _GLIBCXX_HAVE_TANL: u32 = 1;
pub const _GLIBCXX_HAVE_TGMATH_H: u32 = 1;
pub const _GLIBCXX_HAVE_TIMESPEC_GET: u32 = 1;
pub const _GLIBCXX_HAVE_TLS: u32 = 1;
pub const _GLIBCXX_HAVE_TRUNCATE: u32 = 1;
pub const _GLIBCXX_HAVE_UCHAR_H: u32 = 1;
pub const _GLIBCXX_HAVE_UNISTD_H: u32 = 1;
pub const _GLIBCXX_HAVE_UNLINKAT: u32 = 1;
pub const _GLIBCXX_HAVE_USELOCALE: u32 = 1;
pub const _GLIBCXX_HAVE_UTIME_H: u32 = 1;
pub const _GLIBCXX_HAVE_VFWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_VSWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_VWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_WCHAR_H: u32 = 1;
pub const _GLIBCXX_HAVE_WCSTOF: u32 = 1;
pub const _GLIBCXX_HAVE_WCTYPE_H: u32 = 1;
pub const _GLIBCXX_HAVE_WRITEV: u32 = 1;
pub const _GLIBCXX_HAVE___CXA_THREAD_ATEXIT_IMPL: u32 = 1;
pub const _GLIBCXX_LT_OBJDIR: &[u8; 7usize] = b".libs/\0";
pub const _GLIBCXX_PACKAGE_BUGREPORT: &[u8; 1usize] = b"\0";
pub const _GLIBCXX_PACKAGE_NAME: &[u8; 15usize] = b"package-unused\0";
pub const _GLIBCXX_PACKAGE_STRING: &[u8; 30usize] = b"package-unused version-unused\0";
pub const _GLIBCXX_PACKAGE_TARNAME: &[u8; 10usize] = b"libstdc++\0";
pub const _GLIBCXX_PACKAGE_URL: &[u8; 1usize] = b"\0";
pub const _GLIBCXX_PACKAGE__GLIBCXX_VERSION: &[u8; 15usize] = b"version-unused\0";
pub const _GLIBCXX_STDC_HEADERS: u32 = 1;
pub const _GLIBCXX_DARWIN_USE_64_BIT_INODE: u32 = 1;
pub const _GLIBCXX11_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX11_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX11_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX98_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX98_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX98_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX_ATOMIC_BUILTINS: u32 = 1;
pub const _GLIBCXX_CAN_ALIGNAS_DESTRUCTIVE_SIZE: u32 = 1;
pub const _GLIBCXX_FULLY_DYNAMIC_STRING: u32 = 0;
pub const _GLIBCXX_HAS_GTHREADS: u32 = 1;
pub const _GLIBCXX_RES_LIMITS: u32 = 1;
pub const _GLIBCXX_STATIC_TZDATA: u32 = 1;
pub const _GLIBCXX_STDIO_EOF: i32 = -1;
pub const _GLIBCXX_STDIO_SEEK_CUR: u32 = 1;
pub const _GLIBCXX_STDIO_SEEK_END: u32 = 2;
pub const _GLIBCXX_SYMVER: u32 = 1;
pub const _GLIBCXX_SYMVER_GNU: u32 = 1;
pub const _GLIBCXX_USE_C11_UCHAR_CXX11: u32 = 1;
pub const _GLIBCXX_USE_C99: u32 = 1;
pub const _GLIBCXX_USE_C99_COMPLEX_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_CTYPE_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_FENV_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_MATH_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_STDINT_TR1: u32 = 1;
pub const _GLIBCXX_USE_CLOCK_MONOTONIC: u32 = 1;
pub const _GLIBCXX_USE_CLOCK_REALTIME: u32 = 1;
pub const _GLIBCXX_USE_DECIMAL_FLOAT: u32 = 1;
pub const _GLIBCXX_USE_DEV_RANDOM: u32 = 1;
pub const _GLIBCXX_USE_FCHMOD: u32 = 1;
pub const _GLIBCXX_USE_FCHMODAT: u32 = 1;
pub const _GLIBCXX_USE_GETTIMEOFDAY: u32 = 1;
pub const _GLIBCXX_USE_GET_NPROCS: u32 = 1;
pub const _GLIBCXX_USE_LFS: u32 = 1;
pub const _GLIBCXX_USE_LONG_LONG: u32 = 1;
pub const _GLIBCXX_USE_LSTAT: u32 = 1;
pub const _GLIBCXX_USE_NANOSLEEP: u32 = 1;
pub const _GLIBCXX_USE_NLS: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_MUTEX_CLOCKLOCK: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_RWLOCK_CLOCKLOCK: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_RWLOCK_T: u32 = 1;
pub const _GLIBCXX_USE_RANDOM_TR1: u32 = 1;
pub const _GLIBCXX_USE_REALPATH: u32 = 1;
pub const _GLIBCXX_USE_SCHED_YIELD: u32 = 1;
pub const _GLIBCXX_USE_SC_NPROCESSORS_ONLN: u32 = 1;
pub const _GLIBCXX_USE_SENDFILE: u32 = 1;
pub const _GLIBCXX_USE_ST_MTIM: u32 = 1;
pub const _GLIBCXX_USE_TMPNAM: u32 = 1;
pub const _GLIBCXX_USE_UTIME: u32 = 1;
pub const _GLIBCXX_USE_UTIMENSAT: u32 = 1;
pub const _GLIBCXX_USE_WCHAR_T: u32 = 1;
pub const _GLIBCXX_VERBOSE: u32 = 1;
pub const _GLIBCXX_X86_RDRAND: u32 = 1;
pub const _GLIBCXX_X86_RDSEED: u32 = 1;
pub const _GLIBCXX_ZONEINFO_DIR: &[u8; 20usize] = b"/usr/share/zoneinfo\0";
pub const _GTHREAD_USE_MUTEX_TIMEDLOCK: u32 = 1;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type cvoid_t = ::std::os::raw::c_void;
pub type cchar_t = ::std::os::raw::c_char;
pub type cuint8_t = u8;
pub type cuint64_t = u64;
pub type PanError = u32;
pub type PanUDPAddr = usize;
pub type PanConn = usize;
pub type PanListenConn = usize;
pub type PanScionSocket = usize;
pub type PanPath = usize;
pub type PanPathFingerprint = usize;
pub type PanPathInterface = usize;
pub type PanPolicy = usize;
pub type PanSelector = usize;
pub type PanReplySelector = usize;
pub type PanConnSockAdapter = usize;
pub type PanConnSSockAdapter = usize;
pub type PanListenSockAdapter = usize;
pub type PanListenSSockAdapter = usize;
pub type OnCompletionWaker =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: PanError)>;
pub type PanPolicyFilterFn = ::std::option::Option<
    unsafe extern "C" fn(paths: *mut PanPath, count: usize, user: usize) -> PanPath,
>;
pub type PanSelectorPathFn = ::std::option::Option<unsafe extern "C" fn(user: usize) -> PanPath>;
#[doc = " Handles must be deleted by callee."]
pub type PanSelectorInitializeFn = ::std::option::Option<
    unsafe extern "C" fn(
        local: PanUDPAddr,
        remote: PanUDPAddr,
        paths: *mut PanPath,
        count: usize,
        user: usize,
    ),
>;
#[doc = " Handles must be deleted by callee."]
pub type PanSelectorRefreshFn =
    ::std::option::Option<unsafe extern "C" fn(paths: *mut PanPath, count: usize, user: usize)>;
#[doc = " Handles must be deleted by callee."]
pub type PanSelectorPathDownFn = ::std::option::Option<
    unsafe extern "C" fn(pf: PanPathFingerprint, pi: PanPathInterface, user: usize),
>;
pub type PanSelectorClose = ::std::option::Option<unsafe extern "C" fn(user: usize)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PanSelectorCallbacks {
    pub path: PanSelectorPathFn,
    pub initialize: PanSelectorInitializeFn,
    pub refresh: PanSelectorRefreshFn,
    pub pathDown: PanSelectorPathDownFn,
    pub close: PanSelectorClose,
}
#[test]
fn bindgen_test_layout_PanSelectorCallbacks() {
    const UNINIT: ::std::mem::MaybeUninit<PanSelectorCallbacks> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PanSelectorCallbacks>(),
        40usize,
        concat!("Size of: ", stringify!(PanSelectorCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<PanSelectorCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(PanSelectorCallbacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PanSelectorCallbacks),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initialize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PanSelectorCallbacks),
            "::",
            stringify!(initialize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refresh) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PanSelectorCallbacks),
            "::",
            stringify!(refresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pathDown) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PanSelectorCallbacks),
            "::",
            stringify!(pathDown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PanSelectorCallbacks),
            "::",
            stringify!(close)
        )
    );
}
#[doc = " Handles must be deleted by callee."]
pub type PanReplySelPathFn =
    ::std::option::Option<unsafe extern "C" fn(remote: PanUDPAddr, user: usize) -> PanPath>;
pub type PanReplySelInitializeFn =
    ::std::option::Option<unsafe extern "C" fn(local: u64, user: usize)>;
#[doc = " Handles must be deleted by callee."]
pub type PanReplySelRecordFn =
    ::std::option::Option<unsafe extern "C" fn(remote: PanUDPAddr, path: PanPath, user: usize)>;
#[doc = " Handles must be deleted by callee."]
pub type PanReplySelPathDownFn = ::std::option::Option<
    unsafe extern "C" fn(pf: PanPathFingerprint, pi: PanPathInterface, user: usize),
>;
pub type PanReplySelCloseFn = ::std::option::Option<unsafe extern "C" fn(user: usize)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PanReplySelCallbacks {
    pub path: PanReplySelPathFn,
    pub initialize: PanReplySelInitializeFn,
    pub record: PanReplySelRecordFn,
    pub pathDown: PanReplySelPathDownFn,
    pub close: PanReplySelCloseFn,
}
#[test]
fn bindgen_test_layout_PanReplySelCallbacks() {
    const UNINIT: ::std::mem::MaybeUninit<PanReplySelCallbacks> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PanReplySelCallbacks>(),
        40usize,
        concat!("Size of: ", stringify!(PanReplySelCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<PanReplySelCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(PanReplySelCallbacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PanReplySelCallbacks),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initialize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PanReplySelCallbacks),
            "::",
            stringify!(initialize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).record) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PanReplySelCallbacks),
            "::",
            stringify!(record)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pathDown) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PanReplySelCallbacks),
            "::",
            stringify!(pathDown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PanReplySelCallbacks),
            "::",
            stringify!(close)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GoString_ {
    pub p: *const ::std::os::raw::c_char,
    pub n: isize,
}
#[test]
fn bindgen_test_layout__GoString_() {
    const UNINIT: ::std::mem::MaybeUninit<_GoString_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GoString_>(),
        16usize,
        concat!("Size of: ", stringify!(_GoString_))
    );
    assert_eq!(
        ::std::mem::align_of::<_GoString_>(),
        8usize,
        concat!("Alignment of ", stringify!(_GoString_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GoString_),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GoString_),
            "::",
            stringify!(n)
        )
    );
}
pub type GoInt8 = ::std::os::raw::c_schar;
pub type GoUint8 = ::std::os::raw::c_uchar;
pub type GoInt16 = ::std::os::raw::c_short;
pub type GoUint16 = ::std::os::raw::c_ushort;
pub type GoInt32 = ::std::os::raw::c_int;
pub type GoUint32 = ::std::os::raw::c_uint;
pub type GoInt64 = ::std::os::raw::c_longlong;
pub type GoUint64 = ::std::os::raw::c_ulonglong;
pub type GoInt = GoInt64;
pub type GoUint = GoUint64;
pub type GoUintptr = usize;
pub type GoFloat32 = f32;
pub type GoFloat64 = f64;
pub type GoComplex64 = __BindgenComplex<f32>;
pub type GoComplex128 = __BindgenComplex<f64>;
pub type _check_for_64_bit_pointer_matching_GoInt = [::std::os::raw::c_char; 1usize];
pub type GoString = _GoString_;
pub type GoMap = *mut ::std::os::raw::c_void;
pub type GoChan = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GoInterface {
    pub t: *mut ::std::os::raw::c_void,
    pub v: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_GoInterface() {
    const UNINIT: ::std::mem::MaybeUninit<GoInterface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GoInterface>(),
        16usize,
        concat!("Size of: ", stringify!(GoInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<GoInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(GoInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GoInterface),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GoInterface),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GoSlice {
    pub data: *mut ::std::os::raw::c_void,
    pub len: GoInt,
    pub cap: GoInt,
}
#[test]
fn bindgen_test_layout_GoSlice() {
    const UNINIT: ::std::mem::MaybeUninit<GoSlice> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GoSlice>(),
        24usize,
        concat!("Size of: ", stringify!(GoSlice))
    );
    assert_eq!(
        ::std::mem::align_of::<GoSlice>(),
        8usize,
        concat!("Alignment of ", stringify!(GoSlice))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GoSlice),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GoSlice),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GoSlice),
            "::",
            stringify!(cap)
        )
    );
}
extern "C" {
    #[doc = "\\brief Duplicate a cgo handle.\n\\ingroup handle"]
    pub fn PanDuplicateHandle(handle: usize) -> usize;
}
extern "C" {
    #[doc = "\\brief Delete a handle obtained from cgo.\n\\ingroup handle"]
    pub fn PanDeleteHandle(handle: usize);
}
extern "C" {
    #[doc = "\\brief Wrapper for `pan.ResolveUDPAddr`\nA handle to the resolved address is returned in `resolved`.\n\\attention deprecated in favour of PanResolveUDPAddrN\nReason:\tconversion of C to Go string with func C.GoString(p *_Ctype_char) string\nhas been repeatedly found to be unreliable and cause bugs.\n\\ingroup addresses"]
    pub fn PanResolveUDPAddr(
        address: *const ::std::os::raw::c_char,
        resolved: *mut PanUDPAddr,
    ) -> PanError;
}
extern "C" {
    pub fn PanResolveUDPAddrN(
        address: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        resolved: *mut PanUDPAddr,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Create a PanUDPAddr from ISD, ASN, IP and UDP port.\n\\param[in] ia Pointer to the ISD and AS number packed as 8 bytes in big-endian\nbyte order. Must not be NULL.\n\\param[in] ip Pointer to the IP address in big-endian byte order. Must not be\nNULL.\n\\param[in] ip_len Length of the IP address in bytes. Must be 4 or 16.\n\\param[in] port UDP port number\n\\return UDPAddr handle. A null handle is returned if \\p ip_len is not 4 or 16.\n\\ingroup addresses"]
    pub fn PanUDPAddrNew(
        ia: *const ::std::os::raw::c_ulong,
        ip: *const ::std::os::raw::c_uchar,
        ip_len: ::std::os::raw::c_int,
        port: u16,
    ) -> PanUDPAddr;
}
extern "C" {
    #[doc = "\\brief Get the ISD (2 bytes) and ASN (6 bytes) of the address.\n\\param[out] Pointer to 8 bytes that will receive the ISD and AS number in\nbig-endian byte order. Function is a no-op if this is `NULL`.\n\\ingroup addresses"]
    pub fn PanUDPAddrGetIA(addr: PanUDPAddr, ia: *mut u64);
}
extern "C" {
    #[doc = "\\brief Returns whether the IP-part of the address is IPv6 (including mapped IPv4\naddresses).\n\\return `0` for IPv4 addresses, non-zero otherwise.\n\\ingroup addresses"]
    pub fn PanUDPAddrIsIPv6(addr: PanUDPAddr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Get the IP part of the address. Fails if the address is not an IPv4\nor IPv4-in-IPv6 address.\n\\param[out] ipv4 Pointer to a 4-byte array that will receive the IP address.\nFunction is a no-op if this is `NULL`.\n\\return `PAN_ERR_OK` if no error occurred.\n`PAN_ERR_FAILED` if the address cannot be represented in 4 bytes.\n\\ingroup addresses"]
    pub fn PanUDPAddrGetIPv4(addr: PanUDPAddr, ip4: *mut u8) -> PanError;
}
extern "C" {
    #[doc = "\\brief Get the IP part of the address. IPv4 addresses are returned in\nIPv6-mapped form.\n\\param[out] ipv6 Pointer to a 16-byte array that will receive the IP address.\nFunction is a no-op if this is `NULL`.\n\\return `PAN_ERR_OK` if no error occurred.\n\\ingroup addresses"]
    pub fn PanUDPAddrGetIPv6(addr: PanUDPAddr, ip6: *mut u8) -> PanError;
}
extern "C" {
    #[doc = "\\brief Get the UDP port as integer in host byte order.\n\\ingroup addresses"]
    pub fn PanUDPAddrGetPort(addr: PanUDPAddr) -> u16;
}
extern "C" {
    #[doc = "\\brief Returns a string representation of the given SCION address.\nThe returned string must be freed with free().\n\\ingroup addresses"]
    pub fn PanUDPAddrToString(addr: PanUDPAddr) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Return a string representing the path.\nThe returned string must be freed with free().\n\\ingroup path"]
    pub fn PanPathToString(path: PanPath) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Get the fingerprint of the path.\n\\ingroup path"]
    pub fn PanPathGetFingerprint(path: PanPath) -> PanPathFingerprint;
}
extern "C" {
    #[doc = "\\brief Check whether a path contains a certain AS interface.\n\\ingroup path"]
    pub fn PanPathContainsInterface(
        path: PanPath,
        iface: PanPathInterface,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Check whether two path fingerprints compare equal.\n\\ingroup path_fingerprint"]
    pub fn PanPathFingerprintAreEqual(
        fp_a: PanPathFingerprint,
        fp_b: PanPathFingerprint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Create a new path policy from a filter function.\n\\param[in] filter Filter callback.\n\\param[in] user User data that will be passed to the callback.\n\\ingroup policy"]
    pub fn PanNewCPolicy(filter: PanPolicyFilterFn, user: usize) -> PanPolicy;
}
extern "C" {
    pub fn PanCPolicyTest(policy: PanPolicy);
}
extern "C" {
    #[doc = "\\brief Create a new path selector.\n\\param[in] callbacks Callbacks for the methods of the path selector.\n\\param[in] user User data that will be passed to the callback.\n\\ingroup selector"]
    pub fn PanNewCSelector(callbacks: *mut PanSelectorCallbacks, user: usize) -> PanSelector;
}
extern "C" {
    #[doc = "\\brief Create a new reply selector.\n\\param[in] callbacks Callbacks for the methods of the reply selector.\n\\param[in] user User data that will be passed to the callback.\n\\ingroup reply_selector"]
    pub fn PanNewCReplySelector(
        callbacks: *mut PanReplySelCallbacks,
        user: usize,
    ) -> PanReplySelector;
}
extern "C" {
    pub fn PanNewScionSocket(
        listen: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
    ) -> PanScionSocket;
}
extern "C" {
    pub fn PanNewScionSocket2() -> PanScionSocket;
}
extern "C" {
    pub fn PanScionSocketBind(
        socket: PanScionSocket,
        listen: *const ::std::os::raw::c_char,
    ) -> PanError;
}
extern "C" {
    pub fn PanScionSocketGetLocalAddr(socket: PanScionSocket) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn PanScionSocketReadFromAsync(
        conn: PanScionSocket,
        buffer: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        from: *mut PanUDPAddr,
        n: *mut ::std::os::raw::c_int,
        timeout_duration: ::std::os::raw::c_int,
        waker: OnCompletionWaker,
        arc_conn: *mut ::std::os::raw::c_void,
    ) -> PanError;
}
extern "C" {
    pub fn PanScionSocketWriteToAsync(
        conn: PanScionSocket,
        buffer: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        to: PanUDPAddr,
        n: *mut ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
        waker: OnCompletionWaker,
        arc_conn: *mut ::std::os::raw::c_void,
    ) -> PanError;
}
extern "C" {
    pub fn PanScionSocketWriteToViaAsync(
        conn: PanScionSocket,
        buffer: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        to: PanUDPAddr,
        path: PanPath,
        n: *mut ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
        waker: OnCompletionWaker,
        arc_conn: *mut ::std::os::raw::c_void,
    ) -> PanError;
}
extern "C" {
    pub fn PanScionSocketReadFromAsyncVia(
        conn: PanScionSocket,
        buffer: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        from: *mut PanUDPAddr,
        path: *mut PanPath,
        n: *mut ::std::os::raw::c_int,
        timeout_duration: ::std::os::raw::c_int,
        waker: OnCompletionWaker,
        arc_conn: *mut ::std::os::raw::c_void,
    ) -> PanError;
}
extern "C" {
    pub fn PanScionSocketClose(conn: PanScionSocket) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.ListenConn).SetDeadline`\n\\param[in] conn Connection to set the deadline on.\n\\param[in] t is the number milliseconds the deadline is set in the future.\n\\ingroup listen_conn"]
    pub fn PanScionSocketSetDeadline(conn: PanScionSocket, t: u32) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.ListenConn).SetReadDeadline`\n\\param[in] conn Connection to set the deadline on.\n\\param[in] t is the number milliseconds the deadline is set in the future.\n\\ingroup listen_conn"]
    pub fn PanScionSocketSetReadDeadline(conn: PanScionSocket, t: u32) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.ListenConn).SetWriteDeadline`\n\\param[in] conn Connection to set the deadline on.\n\\param[in] t is the number milliseconds the deadline is set in the future.\n\\ingroup listen_conn"]
    pub fn PanScionSocketSetWriteDeadline(conn: PanScionSocket, t: u32) -> PanError;
}
extern "C" {
    #[doc = "\\brief Open a UDP socket and listen for connections.\n\\param[in] listen is the local IP and port to listen on as a null-terminated\nstring (e.g., \"127.0.0.1:8000\").\n\\param[in] selector Reply path selector. May be a PAN_INVALID_HANDLE to use the\ndefault selector.\n\\param[out] conn The value pointed to by \\p conn receives the listening\nconnection handle if the call is successful.\n\\ingroup listen_conn\n\\return `PAN_ERR_OK` on success.\n`PAN_ERR_ADDR_SYNTAX` is the listen address has an invalid format.\n`PAN_ERR_FAILED` if binding and listening on the socket failed."]
    pub fn PanListenUDP(
        listen: *const ::std::os::raw::c_char,
        selector: PanReplySelector,
        conn: *mut PanListenConn,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.ListenConn).ReadFrom`\n\\param[in] conn Listening connection.\n\\param[in] buffer Pointer to a buffer that will receive the packet.\n\\param[in] len Size of \\p buffer in bytes.\n\\param[out] from Host from which data was received. Can be NULL to ignore.\n\\param[out] n Number of bytes read. Can be NULL to ignore.\n\\return `PAN_ERR_OK` on success.\n`PAN_ERR_DEADLINE` if the deadline was exceeded.\n`PAN_ERR_FAILED` if the operation failed.\n\\ingroup listen_conn"]
    pub fn PanListenConnReadFrom(
        conn: PanListenConn,
        buffer: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        from: *mut PanUDPAddr,
        n: *mut ::std::os::raw::c_int,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.ListenConn).ReadFrom`\n\\param[in] conn Listening connection.\n\\param[in] buffer Pointer to a buffer that will receive the packet.\n\\param[in] len Size of \\p buffer in bytes.\n\\param[out] from Host from which data was received. Can be NULL to ignore.\n\\param[out] n Number of bytes read. Can be NULL to ignore.\n\\return `PAN_ERR_OK` on success.\n`PAN_ERR_DEADLINE` if the deadline was exceeded.\n`PAN_ERR_FAILED` if the operation failed.\n\\ingroup listen_conn"]
    pub fn PanListenConnReadFromAsync(
        conn: PanListenConn,
        buffer: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        from: *mut PanUDPAddr,
        n: *mut ::std::os::raw::c_int,
        timeout_duration: ::std::os::raw::c_int,
        waker: OnCompletionWaker,
        arc_conn: *mut ::std::os::raw::c_void,
    ) -> PanError;
}
extern "C" {
    pub fn PanListenConnReadFromAsyncVia(
        conn: PanListenConn,
        buffer: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        from: *mut PanUDPAddr,
        path: *mut PanPath,
        n: *mut ::std::os::raw::c_int,
        timeout_duration: ::std::os::raw::c_int,
        waker: OnCompletionWaker,
        arc_conn: *mut ::std::os::raw::c_void,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.ListenConn).ReadFromVia`\n\\param[in] conn Listening connection.\n\\param[in] buffer Pointer to a buffer that will receive the packet.\n\\param[in] len Size of \\p buffer in bytes.\n\\param[out] from Host from which data was received. Can be NULL to ignore.\n\\param[out] path Path of the received packet. Can be NULL to ignore.\n\\param[out] n Number of bytes read. Can be NULL to ignore.\n\\return `PAN_ERR_OK` on success.\n`PAN_ERR_DEADLINE` if the deadline was exceeded.\n`PAN_ERR_FAILED` if the operation failed.\n\\ingroup listen_conn"]
    pub fn PanListenConnReadFromVia(
        conn: PanListenConn,
        buffer: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        from: *mut PanUDPAddr,
        path: *mut PanPath,
        n: *mut ::std::os::raw::c_int,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\briefWrapper for `(pan.ListenConn).WriteTo`\n\\param[in] conn Listening connection.\n\\param[in] buffer Pointer to a buffer containing the message.\n\\param[in] len Length of the message in \\p buffer in bytes.\n\\param[in] to Destination address.\n\\param[out] n Number of bytes written. Can be NULL to ignore.\n\\return `PAN_ERR_OK` on success.\n`PAN_ERR_DEADLINE` if the deadline was exceeded.\n`PAN_ERR_NO_PATH` if no path to the destination is known.\n`PAN_ERR_FAILED` if the operation failed in some other way.\n\\ingroup listen_conn"]
    pub fn PanListenConnWriteTo(
        conn: PanListenConn,
        buffer: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        to: PanUDPAddr,
        n: *mut ::std::os::raw::c_int,
    ) -> PanError;
}
extern "C" {
    pub fn PanListenConnWriteToAsync(
        conn: PanListenConn,
        buffer: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        to: PanUDPAddr,
        n: *mut ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
        waker: OnCompletionWaker,
        arc_conn: *mut ::std::os::raw::c_void,
    ) -> PanError;
}
extern "C" {
    pub fn PanListenConnWriteToViaAsync(
        conn: PanListenConn,
        buffer: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        to: PanUDPAddr,
        path: PanPath,
        n: *mut ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
        waker: OnCompletionWaker,
        arc_conn: *mut ::std::os::raw::c_void,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.ListenConn).WriteToVia`\n\\param[in] conn Listening connection.\n\\param[in] buffer Pointer to a buffer containing the message.\n\\param[in] len Length of the message in \\p buffer in bytes.\n\\param[in] to Destination address.\n\\param[in] path Path to take to the destination.\n\\param[out] n Number of bytes written. Can be NULL to ignore.\n\\return `PAN_ERR_OK` on success.\n`PAN_ERR_DEADLINE` if the deadline was exceeded.\n`PAN_ERR_FAILED` if the operation failed.\n\\ingroup listen_conn"]
    pub fn PanListenConnWriteToVia(
        conn: PanListenConn,
        buffer: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        to: PanUDPAddr,
        path: PanPath,
        n: *mut ::std::os::raw::c_int,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.ListenConn).LocalAddr`\n\\ingroup listen_conn"]
    pub fn PanListenConnLocalAddr(conn: PanListenConn) -> PanUDPAddr;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.ListenConn).SetDeadline`\n\\param[in] conn Connection to set the deadline on.\n\\param[in] t is the number milliseconds the deadline is set in the future.\n\\ingroup listen_conn"]
    pub fn PanListenConnSetDeadline(conn: PanListenConn, t: u32) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.ListenConn).SetReadDeadline`\n\\param[in] conn Connection to set the deadline on.\n\\param[in] t is the number milliseconds the deadline is set in the future.\n\\ingroup listen_conn"]
    pub fn PanListenConnSetReadDeadline(conn: PanListenConn, t: u32) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.ListenConn).SetWriteDeadline`\n\\param[in] conn Connection to set the deadline on.\n\\param[in] t is the number milliseconds the deadline is set in the future.\n\\ingroup listen_conn"]
    pub fn PanListenConnSetWriteDeadline(conn: PanListenConn, t: u32) -> PanError;
}
extern "C" {
    #[doc = "\\brief Close a listening socket. The handle must still be deleted with\nPanDeleteHandle().\n\\ingroup listen_conn"]
    pub fn PanListenConnClose(conn: PanListenConn) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `pan.DialUDP`\n\\param[in] local is the local IP and port as string. Can be NULL to automatically\nchoose.\n\\param[in] remote is the SCION address of the remote host.\n\\param[in] policy Path policy. May be a PAN_INVALID_HANDLE to use the default\npolicy.\n\\param[in] selector Path selector. May be a PAN_INVALID_HANDLE to use the\ndefault selector.\n\\param[out] conn The value pointed to by \\p conn receives the connection handle\nif the call is successful.\n\\return `PAN_ERR_OK` on success.\n`PAN_ERR_ADDR_SYNTAX` is the local address has an invalid format.\n`PAN_ERR_FAILED` if dialing failed.\n\\ingroup conn"]
    pub fn PanDialUDP(
        local: *const ::std::os::raw::c_char,
        remote: PanUDPAddr,
        policy: PanPolicy,
        selector: PanSelector,
        conn: *mut PanConn,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.Conn).Read`\n\\param[in] conn Connection\n\\param[in] buffer Pointer to a buffer that will receive the packet.\n\\param[in] len Size of \\p buffer in bytes.\n\\param[out] n Number of bytes read. Can be NULL to ignore.\n\\return `PAN_ERR_OK` on success.\n`PAN_ERR_DEADLINE` if the deadline was exceeded.\n`PAN_ERR_FAILED` if the operation failed.\n\\ingroup conn"]
    pub fn PanConnRead(
        conn: PanConn,
        buffer: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.Conn).ReadVia`\n\\param[in] conn Connection\n\\param[in] buffer Pointer to a buffer that will receive the packet.\n\\param[in] len Size of \\p buffer in bytes.\n\\param[out] path Path of the received packet. Can be NULL to ignore.\n\\param[out] n Number of bytes read. Can be NULL to ignore.\n\\return `PAN_ERR_OK` on success.\n`PAN_ERR_DEADLINE` if the deadline was exceeded.\n`PAN_ERR_FAILED` if the operation failed.\n\\ingroup conn"]
    pub fn PanConnReadVia(
        conn: PanConn,
        buffer: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        path: *mut PanPath,
        n: *mut ::std::os::raw::c_int,
    ) -> PanError;
}
extern "C" {
    pub fn PanConnReadViaAsync(
        conn: PanConn,
        buffer: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        path: *mut PanPath,
        n: *mut ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
        waker: OnCompletionWaker,
        arc_conn: *mut ::std::os::raw::c_void,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.Conn).Write`\n\\param[in] conn Connection\n\\param[in] buffer Pointer to a buffer containing the message.\n\\param[in] len Length of the message in \\p buffer in bytes.\n\\param[out] n Number of bytes written. Can be NULL to ignore.\n\\return `PAN_ERR_OK` on success.\n`PAN_ERR_DEADLINE` if the deadline was exceeded.\n`PAN_ERR_NO_PATH` if no path to the destination is known.\n`PAN_ERR_FAILED` if the operation failed in some other way.\n\\ingroup conn"]
    pub fn PanConnWrite(
        conn: PanListenConn,
        buffer: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
    ) -> PanError;
}
extern "C" {
    pub fn PanConnWriteAsync(
        conn: PanListenConn,
        buffer: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
        waker: OnCompletionWaker,
        arc_conn: *mut ::std::os::raw::c_void,
    ) -> PanError;
}
extern "C" {
    pub fn GetLocalIA() -> GoUint64;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.Conn).WriteVia`\n\\param[in] conn Connection\n\\param[in] buffer Pointer to a buffer containing the message.\n\\param[in] len Length of the message in \\p buffer in bytes.\n\\param[in] path Path to take to the destination.\n\\param[out] n Number of bytes written. Can be NULL to ignore.\n\\return `PAN_ERR_OK` on success.\n`PAN_ERR_DEADLINE` if the deadline was exceeded.\n`PAN_ERR_FAILED` if the operation failed.\n\\ingroup conn"]
    pub fn PanConnWriteVia(
        conn: PanListenConn,
        buffer: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        path: PanPath,
        n: *mut ::std::os::raw::c_int,
    ) -> PanError;
}
extern "C" {
    pub fn PanConnWriteViaAsync(
        conn: PanListenConn,
        buffer: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        path: PanPath,
        n: *mut ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
        waker: OnCompletionWaker,
        arc_conn: *mut ::std::os::raw::c_void,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for (pan.Conn).LocalAddr\n\\ingroup conn"]
    pub fn PanConnLocalAddr(conn: PanConn) -> PanUDPAddr;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.Conn).RemoteAddr`\n\\ingroup conn"]
    pub fn PanConnRemoteAddr(conn: PanConn) -> PanUDPAddr;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.Conn).SetDeadline`\n\\param[in] conn Connection to set the deadline on.\n\\param[in] t is the number milliseconds the deadline is set in the future.\n\\ingroup conn"]
    pub fn PanConnSetDeadline(conn: PanConn, t: u32) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.Conn).SetReadDeadline`\n\\param[in] conn Connection to set the deadline on.\n\\param[in] t is the number milliseconds the deadline is set in the future.\n\\ingroup conn"]
    pub fn PanConnSetReadDeadline(conn: PanConn, t: u32) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.Conn).SetWriteDeadline`\n\\param[in] conn Connection to set the deadline on.\n\\param[in] t is the number milliseconds the deadline is set in the future.\n\\ingroup conn"]
    pub fn PanConnSetWriteDeadline(conn: PanConn, t: u32) -> PanError;
}
extern "C" {
    #[doc = "\\brief Close a connection. The handle must still be deleted with\nPanDeleteHandle().\n\\ingroup conn"]
    pub fn PanConnClose(conn: PanConn) -> PanError;
}
extern "C" {
    #[doc = "\\brief Open a Unix datagram socket at `listen_addr` as proxy for `pan_conn` or scion_socket (any SocketLike type).\n\\attention deprecated in favour of PanNewListenSockAdapter2\nReason:\tconversion of C to Go string with func C.GoString(p *_Ctype_char) string has been repeatedly found to be unreliable and cause bugs.\nAll packets received by `pan_conn` are forwarded from `listen_addr` to `client_addr`.\nAll packets received from the Unix socket are forwarded to `pan_conn`.\nThe SCION address of the source or destination is prepended to the payload in a\n32 byte header:\n\\verbatim\nbyte 0       1       2       3       4       5       6       7\n+-------+-------+-------+-------+-------+-------+-------+-------+\n0 |    ISD (BE)   |                     ASN (BE)                  |\n+-------+-------+-------+-------+-------+-------+-------+-------+\n8 |    Host Addr. Length (LE)     |                               |\n+-------+-------+-------+-------+                               |\n16 |                         Host Address (BE)                     |\n+                               +-------+-------+-------+-------+\n24 |                               | UDP Port (LE) |       0       |\n+-------+-------+-------+-------+-------+-------+-------+-------+\nBE = big-endian\nLE = little-endian\n\\endverbatim\n\n\\param[in] pan_conn Listening PAN connection or ScionSocket (any type that implements SocketLike).\n\\param[in] listen_addr Local address of the socket in the file system.\nOn the 'FFI caller' side a unix domain socket must have been constructed an bound to this address\nbefore the adapter is constructed.\n\\param[in] client_addr Address of the other end of the connection in the C part\nof the program.\n\\param[out] adapter Socket adapter object.\n\\ingroup adapter"]
    pub fn PanNewListenSockAdapter(
        pan_conn: PanListenConn,
        listen_addr: *const ::std::os::raw::c_char,
        client_addr: *const ::std::os::raw::c_char,
        adapter: *mut PanListenSockAdapter,
    ) -> PanError;
}
extern "C" {
    pub fn PanNewListenSockAdapter2(
        pan_conn: PanListenConn,
        listen_addr: *const ::std::os::raw::c_char,
        len1: ::std::os::raw::c_int,
        client_addr: *const ::std::os::raw::c_char,
        len2: ::std::os::raw::c_int,
        adapter: *mut PanListenSockAdapter,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Close the Unix domain socket **and the PAN connection**.\n\\ingroup adapter"]
    pub fn PanListenSockAdapterClose(adapter: PanListenSockAdapter) -> PanError;
}
extern "C" {
    #[doc = "\\brief Open a Unix datagram socket at `listen_addr` as proxy for `pan_conn`.\n\nAll packets received by pan_conn are forwarded from `listen_addr` to `client_addr`.\nAll packets received from the unix socket are forwarded to `pan_conn`.\n\n\\param[in] pan_conn Connected PAN connection.\n\\param[in] listen_addr Local address of the unix socket in the file system.\n\\param[in] client_addr Address of the other end of the connection in the C part\nof the program.\n\\param[out] adapter Socket adapter object.\n\\ingroup adapter"]
    pub fn PanNewConnSockAdapter(
        pan_conn: PanConn,
        listen_addr: *const ::std::os::raw::c_char,
        client_addr: *const ::std::os::raw::c_char,
        adapter: *mut PanConnSockAdapter,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Close the Unix domain socket **and the PAN connection**.\n\\ingroup adapter"]
    pub fn PanConnSockAdapterClose(adapter: PanConnSockAdapter) -> PanError;
}
extern "C" {
    #[doc = "\\brief Open a Unix stream socket at `listen_addr` as proxy for `pan_conn` or 'scion_socket'(any SocketLike).\n\nBehaves identical to `PanNewListenSockAdapter` except that a stream socket is\nused instead of a datagram socket. Packet borders in the stream are determined\nby prepending a four byte message length (little endian) in front of every\npacket sent or received on the Unix socket.\n\nWhen initially created, the socket will listens for and accept exactly one\nconnection.\n\nThe stream variants of the socket adapters are intended for systems lacking\nsupport for Unix datagram sockets, e.g., Windows. A more native solution on\nWindows might be named pipes, however they have a very different API from\nsockets.\n\n\\param[in] pan_conn Listening PAN connection.\n\\param[in] listen_addr Local address of the socket in the file system.\n\\param[out] adapter Socket adapter object.\n\\ingroup adapter"]
    pub fn PanNewListenSSockAdapter(
        pan_conn: PanListenConn,
        listen_addr: *const ::std::os::raw::c_char,
        adapter: *mut PanListenSSockAdapter,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Close the Unix domain socket **and the PAN connection**.\n\\ingroup adapter"]
    pub fn PanListenSSockAdapterClose(adapter: PanListenSSockAdapter) -> PanError;
}
extern "C" {
    #[doc = "\\brief Open a Unix stream socket at `listen_addr` as proxy for `pan_conn`.\n\nBehaves identical to `PanNewConnSockAdapter` except that a stream socket is\nused instead of a datagram socket. Packet borders in the stream are determined\nby prepending a four byte message length (little endian) in front of every\npacket sent or received on the Unix socket.\n\nWhen initially created, the socket will listens for and accept exactly one\nconnection.\n\nThe stream variants of the socket adapters are intended for systems lacking\nsupport for Unix datagram sockets, e.g., Windows. A more native solution on\nWindows might be named pipes, however they have a very different API from\nsockets.\n\n\\param[in] pan_conn Connected PAN connection.\n\\param[in] listen_addr Local address of the Unix socket in the file system.\n\\param[out] adapter Socket adapter object.\n\\ingroup adapter"]
    pub fn PanNewConnSSockAdapter(
        pan_conn: PanConn,
        listen_addr: *const ::std::os::raw::c_char,
        adapter: *mut PanConnSSockAdapter,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Close the Unix domain socket **and the PAN connection**.\n\\ingroup adapter"]
    pub fn PanConnSSockAdapterClose(adapter: PanConnSSockAdapter) -> PanError;
}
pub type std_nullptr_t = *const ::std::os::raw::c_void;
extern "C" {
    #[link_name = "\u{1}_ZN3Pan4swapERNS_8GoHandleES1_"]
    pub fn Pan_swap(a: *mut Pan_GoHandle, b: *mut Pan_GoHandle);
}
#[doc = " \\brief Wrapper for Cgo handles. Manages the lifetime of the contained handle.\n GoHandle cannot be copied, use duplicate() to create a new unique duplicate\n handle."]
#[repr(C)]
#[derive(Debug)]
pub struct Pan_GoHandle {
    pub handle: ::std::os::raw::c_ulong,
}
pub const Pan_GoHandle_INVALID_HANDLE: ::std::os::raw::c_ulong = 0;
#[test]
fn bindgen_test_layout_Pan_GoHandle() {
    const UNINIT: ::std::mem::MaybeUninit<Pan_GoHandle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Pan_GoHandle>(),
        8usize,
        concat!("Size of: ", stringify!(Pan_GoHandle))
    );
    assert_eq!(
        ::std::mem::align_of::<Pan_GoHandle>(),
        8usize,
        concat!("Alignment of ", stringify!(Pan_GoHandle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Pan_GoHandle),
            "::",
            stringify!(handle)
        )
    );
}
extern "C" {
    #[doc = " \\brief Initialize with a duplicate of the given handle."]
    #[link_name = "\u{1}_ZN3Pan8GoHandle9DuplicateEm"]
    pub fn Pan_GoHandle_Duplicate(handle: ::std::os::raw::c_ulong) -> Pan_GoHandle;
}
extern "C" {
    #[doc = " \\brief Duplicate the contained handle."]
    #[link_name = "\u{1}_ZN3Pan8GoHandle9duplicateEv"]
    pub fn Pan_GoHandle_duplicate(this: *mut Pan_GoHandle) -> Pan_GoHandle;
}
extern "C" {
    #[doc = " \\brief Check whether the handle is not `PAN_INVALID_HANDLE`."]
    #[link_name = "\u{1}_ZNK3Pan8GoHandle7isValidEv"]
    pub fn Pan_GoHandle_isValid(this: *const Pan_GoHandle) -> bool;
}
extern "C" {
    #[doc = " \\brief Get the contained handle."]
    #[link_name = "\u{1}_ZNK3Pan8GoHandle3getEv"]
    pub fn Pan_GoHandle_get(this: *const Pan_GoHandle) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " \\brief Get a pointer to the contained handle.\n \\return Const pointer to contained handle."]
    #[link_name = "\u{1}_ZNK3Pan8GoHandle12getAddressOfEv"]
    pub fn Pan_GoHandle_getAddressOf(this: *const Pan_GoHandle) -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " \\brief Release the old handle and return the address of the contained\n handle for assignment of a new value.\n \\return Mutable pointer to contained handle."]
    #[link_name = "\u{1}_ZN3Pan8GoHandle20resetAndGetAddressOfEv"]
    pub fn Pan_GoHandle_resetAndGetAddressOf(
        this: *mut Pan_GoHandle,
    ) -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " \\brief Delete the owned handle and assign a new one."]
    #[link_name = "\u{1}_ZN3Pan8GoHandle5resetEm"]
    pub fn Pan_GoHandle_reset(this: *mut Pan_GoHandle, newHandle: ::std::os::raw::c_ulong);
}
extern "C" {
    #[doc = " \\brief Delete the owned handle."]
    #[link_name = "\u{1}_ZN3Pan8GoHandle5resetEv"]
    pub fn Pan_GoHandle_reset1(this: *mut Pan_GoHandle);
}
extern "C" {
    #[doc = " \\brief Release ownership of the handle and return it."]
    #[link_name = "\u{1}_ZN3Pan8GoHandle7releaseEv"]
    pub fn Pan_GoHandle_release(this: *mut Pan_GoHandle) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " \\brief Construct an invalid handle."]
    #[link_name = "\u{1}_ZN3Pan8GoHandleC1Ev"]
    pub fn Pan_GoHandle_GoHandle(this: *mut Pan_GoHandle);
}
extern "C" {
    #[doc = " \\brief Take ownership of a handle."]
    #[link_name = "\u{1}_ZN3Pan8GoHandleC1Em"]
    pub fn Pan_GoHandle_GoHandle1(this: *mut Pan_GoHandle, h: ::std::os::raw::c_ulong);
}
extern "C" {
    #[link_name = "\u{1}_ZN3Pan8GoHandleC1ERKS0_"]
    pub fn Pan_GoHandle_GoHandle2(this: *mut Pan_GoHandle, other: *const Pan_GoHandle);
}
extern "C" {
    #[link_name = "\u{1}_ZN3Pan8GoHandleC1EOS0_"]
    pub fn Pan_GoHandle_GoHandle3(this: *mut Pan_GoHandle, other: *mut Pan_GoHandle);
}
extern "C" {
    #[link_name = "\u{1}_ZN3Pan8GoHandleD1Ev"]
    pub fn Pan_GoHandle_GoHandle_destructor(this: *mut Pan_GoHandle);
}
impl Pan_GoHandle {
    #[inline]
    pub unsafe fn Duplicate(handle: ::std::os::raw::c_ulong) -> Pan_GoHandle {
        Pan_GoHandle_Duplicate(handle)
    }
    #[inline]
    pub unsafe fn duplicate(&mut self) -> Pan_GoHandle {
        Pan_GoHandle_duplicate(self)
    }
    #[inline]
    pub unsafe fn isValid(&self) -> bool {
        Pan_GoHandle_isValid(self)
    }
    #[inline]
    pub unsafe fn get(&self) -> ::std::os::raw::c_ulong {
        Pan_GoHandle_get(self)
    }
    #[inline]
    pub unsafe fn getAddressOf(&self) -> *mut ::std::os::raw::c_ulong {
        Pan_GoHandle_getAddressOf(self)
    }
    #[inline]
    pub unsafe fn resetAndGetAddressOf(&mut self) -> *mut ::std::os::raw::c_ulong {
        Pan_GoHandle_resetAndGetAddressOf(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self, newHandle: ::std::os::raw::c_ulong) {
        Pan_GoHandle_reset(self, newHandle)
    }
    #[inline]
    pub unsafe fn reset1(&mut self) {
        Pan_GoHandle_reset1(self)
    }
    #[inline]
    pub unsafe fn release(&mut self) -> ::std::os::raw::c_ulong {
        Pan_GoHandle_release(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Pan_GoHandle_GoHandle(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(h: ::std::os::raw::c_ulong) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Pan_GoHandle_GoHandle1(__bindgen_tmp.as_mut_ptr(), h);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(other: *const Pan_GoHandle) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Pan_GoHandle_GoHandle2(__bindgen_tmp.as_mut_ptr(), other);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(other: *mut Pan_GoHandle) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Pan_GoHandle_GoHandle3(__bindgen_tmp.as_mut_ptr(), other);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        Pan_GoHandle_GoHandle_destructor(self)
    }
}
