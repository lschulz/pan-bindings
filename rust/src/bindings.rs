/* automatically generated by rust-bindgen 0.65.1 */

#[derive(PartialEq, Copy, Clone, Hash, Debug, Default)]
#[repr(C)]
pub struct __BindgenComplex<T> {
    pub re: T,
    pub im: T,
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 38;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const PAN_INVALID_HANDLE: u32 = 0;
pub const PAN_ERR_OK: u32 = 0;
pub const PAN_ERR_FAILED: u32 = 1;
pub const PAN_ERR_DEADLINE: u32 = 2;
pub const PAN_ERR_NO_PATH: u32 = 3;
pub const PAN_ERR_ADDR_SYNTAX: u32 = 4;
pub const PAN_ERR_ADDR_RESOLUTION: u32 = 5;
pub const PAN_ERR_WOULDBLOCK: u32 = 6;
pub const PAN_ERR_HOSTNOTFOUND: u32 = 7;
pub const PAN_STREAM_HDR_SIZE: u32 = 4;
pub const PAN_ADDR_HDR_SIZE: u32 = 32;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type cvoid_t = ::std::os::raw::c_void;
pub type cchar_t = ::std::os::raw::c_char;
pub type cuint8_t = u8;
pub type cuint64_t = u64;
pub type PanError = u32;
pub type PanUDPAddr = usize;
pub type PanConn = usize;
pub type PanListenConn = usize;
pub type PanScionSocket = usize;
pub type PanPath = usize;
pub type PanPathFingerprint = usize;
pub type PanPathInterface = usize;
pub type PanPolicy = usize;
pub type PanSelector = usize;
pub type PanReplySelector = usize;
pub type PanConnSockAdapter = usize;
pub type PanConnSSockAdapter = usize;
pub type PanListenSockAdapter = usize;
pub type PanListenSSockAdapter = usize;
pub type OnCompletionWaker =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: PanError)>;
pub type PanPolicyFilterFn = ::std::option::Option<
    unsafe extern "C" fn(paths: *mut PanPath, count: usize, user: usize) -> PanPath,
>;
pub type PanSelectorPathFn = ::std::option::Option<unsafe extern "C" fn(user: usize) -> PanPath>;
#[doc = " Handles must be deleted by callee."]
pub type PanSelectorInitializeFn = ::std::option::Option<
    unsafe extern "C" fn(
        local: PanUDPAddr,
        remote: PanUDPAddr,
        paths: *mut PanPath,
        count: usize,
        user: usize,
    ),
>;
#[doc = " Handles must be deleted by callee."]
pub type PanSelectorRefreshFn =
    ::std::option::Option<unsafe extern "C" fn(paths: *mut PanPath, count: usize, user: usize)>;
#[doc = " Handles must be deleted by callee."]
pub type PanSelectorPathDownFn = ::std::option::Option<
    unsafe extern "C" fn(pf: PanPathFingerprint, pi: PanPathInterface, user: usize),
>;
pub type PanSelectorClose = ::std::option::Option<unsafe extern "C" fn(user: usize)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PanSelectorCallbacks {
    pub path: PanSelectorPathFn,
    pub initialize: PanSelectorInitializeFn,
    pub refresh: PanSelectorRefreshFn,
    pub pathDown: PanSelectorPathDownFn,
    pub close: PanSelectorClose,
}
#[test]
fn bindgen_test_layout_PanSelectorCallbacks() {
    const UNINIT: ::std::mem::MaybeUninit<PanSelectorCallbacks> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PanSelectorCallbacks>(),
        40usize,
        concat!("Size of: ", stringify!(PanSelectorCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<PanSelectorCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(PanSelectorCallbacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PanSelectorCallbacks),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initialize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PanSelectorCallbacks),
            "::",
            stringify!(initialize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refresh) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PanSelectorCallbacks),
            "::",
            stringify!(refresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pathDown) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PanSelectorCallbacks),
            "::",
            stringify!(pathDown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PanSelectorCallbacks),
            "::",
            stringify!(close)
        )
    );
}
#[doc = " Handles must be deleted by callee."]
pub type PanReplySelPathFn =
    ::std::option::Option<unsafe extern "C" fn(remote: PanUDPAddr, user: usize) -> PanPath>;
pub type PanReplySelInitializeFn =
    ::std::option::Option<unsafe extern "C" fn(local: u64, user: usize)>;
#[doc = " Handles must be deleted by callee."]
pub type PanReplySelRecordFn =
    ::std::option::Option<unsafe extern "C" fn(remote: PanUDPAddr, path: PanPath, user: usize)>;
#[doc = " Handles must be deleted by callee."]
pub type PanReplySelPathDownFn = ::std::option::Option<
    unsafe extern "C" fn(pf: PanPathFingerprint, pi: PanPathInterface, user: usize),
>;
pub type PanReplySelCloseFn = ::std::option::Option<unsafe extern "C" fn(user: usize)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PanReplySelCallbacks {
    pub path: PanReplySelPathFn,
    pub initialize: PanReplySelInitializeFn,
    pub record: PanReplySelRecordFn,
    pub pathDown: PanReplySelPathDownFn,
    pub close: PanReplySelCloseFn,
}
#[test]
fn bindgen_test_layout_PanReplySelCallbacks() {
    const UNINIT: ::std::mem::MaybeUninit<PanReplySelCallbacks> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PanReplySelCallbacks>(),
        40usize,
        concat!("Size of: ", stringify!(PanReplySelCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<PanReplySelCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(PanReplySelCallbacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PanReplySelCallbacks),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initialize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PanReplySelCallbacks),
            "::",
            stringify!(initialize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).record) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PanReplySelCallbacks),
            "::",
            stringify!(record)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pathDown) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PanReplySelCallbacks),
            "::",
            stringify!(pathDown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PanReplySelCallbacks),
            "::",
            stringify!(close)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GoString_ {
    pub p: *const ::std::os::raw::c_char,
    pub n: isize,
}
#[test]
fn bindgen_test_layout__GoString_() {
    const UNINIT: ::std::mem::MaybeUninit<_GoString_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GoString_>(),
        16usize,
        concat!("Size of: ", stringify!(_GoString_))
    );
    assert_eq!(
        ::std::mem::align_of::<_GoString_>(),
        8usize,
        concat!("Alignment of ", stringify!(_GoString_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GoString_),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GoString_),
            "::",
            stringify!(n)
        )
    );
}
pub type GoInt8 = ::std::os::raw::c_schar;
pub type GoUint8 = ::std::os::raw::c_uchar;
pub type GoInt16 = ::std::os::raw::c_short;
pub type GoUint16 = ::std::os::raw::c_ushort;
pub type GoInt32 = ::std::os::raw::c_int;
pub type GoUint32 = ::std::os::raw::c_uint;
pub type GoInt64 = ::std::os::raw::c_longlong;
pub type GoUint64 = ::std::os::raw::c_ulonglong;
pub type GoInt = GoInt64;
pub type GoUint = GoUint64;
pub type GoUintptr = usize;
pub type GoFloat32 = f32;
pub type GoFloat64 = f64;
pub type GoComplex64 = __BindgenComplex<f32>;
pub type GoComplex128 = __BindgenComplex<f64>;
pub type _check_for_64_bit_pointer_matching_GoInt = [::std::os::raw::c_char; 1usize];
pub type GoString = _GoString_;
pub type GoMap = *mut ::std::os::raw::c_void;
pub type GoChan = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GoInterface {
    pub t: *mut ::std::os::raw::c_void,
    pub v: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_GoInterface() {
    const UNINIT: ::std::mem::MaybeUninit<GoInterface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GoInterface>(),
        16usize,
        concat!("Size of: ", stringify!(GoInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<GoInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(GoInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GoInterface),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GoInterface),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GoSlice {
    pub data: *mut ::std::os::raw::c_void,
    pub len: GoInt,
    pub cap: GoInt,
}
#[test]
fn bindgen_test_layout_GoSlice() {
    const UNINIT: ::std::mem::MaybeUninit<GoSlice> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GoSlice>(),
        24usize,
        concat!("Size of: ", stringify!(GoSlice))
    );
    assert_eq!(
        ::std::mem::align_of::<GoSlice>(),
        8usize,
        concat!("Alignment of ", stringify!(GoSlice))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GoSlice),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GoSlice),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GoSlice),
            "::",
            stringify!(cap)
        )
    );
}
extern "C" {
    #[doc = "\\brief Duplicate a cgo handle.\n\\ingroup handle"]
    pub fn PanDuplicateHandle(handle: usize) -> usize;
}
extern "C" {
    #[doc = "\\brief Delete a handle obtained from cgo.\n\\ingroup handle"]
    pub fn PanDeleteHandle(handle: usize);
}
extern "C" {
    #[doc = "\\brief Wrapper for `pan.ResolveUDPAddr`\nA handle to the resolved address is returned in `resolved`.\n\\attention deprecated in favour of PanResolveUDPAddrN\nReason:\tconversion of C to Go string with func C.GoString(p *_Ctype_char) string\nhas been repeatedly found to be unreliable and cause bugs.\n\\ingroup addresses"]
    pub fn PanResolveUDPAddr(
        address: *const ::std::os::raw::c_char,
        resolved: *mut PanUDPAddr,
    ) -> PanError;
}
extern "C" {
    pub fn PanResolveUDPAddrN(
        address: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        resolved: *mut PanUDPAddr,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Create a PanUDPAddr from ISD, ASN, IP and UDP port.\n\\param[in] ia Pointer to the ISD and AS number packed as 8 bytes in big-endian\nbyte order. Must not be NULL.\n\\param[in] ip Pointer to the IP address in big-endian byte order. Must not be\nNULL.\n\\param[in] ip_len Length of the IP address in bytes. Must be 4 or 16.\n\\param[in] port UDP port number\n\\return UDPAddr handle. A null handle is returned if \\p ip_len is not 4 or 16.\n\\ingroup addresses"]
    pub fn PanUDPAddrNew(
        ia: *const ::std::os::raw::c_ulong,
        ip: *const ::std::os::raw::c_uchar,
        ip_len: ::std::os::raw::c_int,
        port: u16,
    ) -> PanUDPAddr;
}
extern "C" {
    #[doc = "\\brief Get the ISD (2 bytes) and ASN (6 bytes) of the address.\n\\param[out] Pointer to 8 bytes that will receive the ISD and AS number in\nbig-endian byte order. Function is a no-op if this is `NULL`.\n\\ingroup addresses"]
    pub fn PanUDPAddrGetIA(addr: PanUDPAddr, ia: *mut u64);
}
extern "C" {
    #[doc = "\\brief Returns whether the IP-part of the address is IPv6 (including mapped IPv4\naddresses).\n\\return `0` for IPv4 addresses, non-zero otherwise.\n\\ingroup addresses"]
    pub fn PanUDPAddrIsIPv6(addr: PanUDPAddr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Get the IP part of the address. Fails if the address is not an IPv4\nor IPv4-in-IPv6 address.\n\\param[out] ipv4 Pointer to a 4-byte array that will receive the IP address.\nFunction is a no-op if this is `NULL`.\n\\return `PAN_ERR_OK` if no error occurred.\n`PAN_ERR_FAILED` if the address cannot be represented in 4 bytes.\n\\ingroup addresses"]
    pub fn PanUDPAddrGetIPv4(addr: PanUDPAddr, ip4: *mut u8) -> PanError;
}
extern "C" {
    #[doc = "\\brief Get the IP part of the address. IPv4 addresses are returned in\nIPv6-mapped form.\n\\param[out] ipv6 Pointer to a 16-byte array that will receive the IP address.\nFunction is a no-op if this is `NULL`.\n\\return `PAN_ERR_OK` if no error occurred.\n\\ingroup addresses"]
    pub fn PanUDPAddrGetIPv6(addr: PanUDPAddr, ip6: *mut u8) -> PanError;
}
extern "C" {
    #[doc = "\\brief Get the UDP port as integer in host byte order.\n\\ingroup addresses"]
    pub fn PanUDPAddrGetPort(addr: PanUDPAddr) -> u16;
}
extern "C" {
    #[doc = "\\brief Returns a string representation of the given SCION address.\nThe returned string must be freed with free().\n\\ingroup addresses"]
    pub fn PanUDPAddrToString(addr: PanUDPAddr) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Return a string representing the path.\nThe returned string must be freed with free().\n\\ingroup path"]
    pub fn PanPathToString(path: PanPath) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Get the fingerprint of the path.\n\\ingroup path"]
    pub fn PanPathGetFingerprint(path: PanPath) -> PanPathFingerprint;
}
extern "C" {
    #[doc = "\\brief Check whether a path contains a certain AS interface.\n\\ingroup path"]
    pub fn PanPathContainsInterface(
        path: PanPath,
        iface: PanPathInterface,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Check whether two path fingerprints compare equal.\n\\ingroup path_fingerprint"]
    pub fn PanPathFingerprintAreEqual(
        fp_a: PanPathFingerprint,
        fp_b: PanPathFingerprint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Create a new path policy from a filter function.\n\\param[in] filter Filter callback.\n\\param[in] user User data that will be passed to the callback.\n\\ingroup policy"]
    pub fn PanNewCPolicy(filter: PanPolicyFilterFn, user: usize) -> PanPolicy;
}
extern "C" {
    pub fn PanCPolicyTest(policy: PanPolicy);
}
extern "C" {
    #[doc = "\\brief Create a new path selector.\n\\param[in] callbacks Callbacks for the methods of the path selector.\n\\param[in] user User data that will be passed to the callback.\n\\ingroup selector"]
    pub fn PanNewCSelector(callbacks: *mut PanSelectorCallbacks, user: usize) -> PanSelector;
}
extern "C" {
    #[doc = "\\brief Create a new reply selector.\n\\param[in] callbacks Callbacks for the methods of the reply selector.\n\\param[in] user User data that will be passed to the callback.\n\\ingroup reply_selector"]
    pub fn PanNewCReplySelector(
        callbacks: *mut PanReplySelCallbacks,
        user: usize,
    ) -> PanReplySelector;
}
extern "C" {
    pub fn PanNewScionSocket(
        listen: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
    ) -> PanScionSocket;
}
extern "C" {
    pub fn PanNewScionSocket2() -> PanScionSocket;
}
extern "C" {
    pub fn PanScionSocketBind(
        socket: PanScionSocket,
        listen: *const ::std::os::raw::c_char,
    ) -> PanError;
}
extern "C" {
    pub fn PanScionSocketGetLocalAddr(socket: PanScionSocket) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn PanScionSocketReadFromAsync(
        conn: PanScionSocket,
        buffer: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        from: *mut PanUDPAddr,
        n: *mut ::std::os::raw::c_int,
        timeout_duration: ::std::os::raw::c_int,
        waker: OnCompletionWaker,
        arc_conn: *mut ::std::os::raw::c_void,
    ) -> PanError;
}
extern "C" {
    pub fn PanScionSocketWriteToAsync(
        conn: PanScionSocket,
        buffer: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        to: PanUDPAddr,
        n: *mut ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
        waker: OnCompletionWaker,
        arc_conn: *mut ::std::os::raw::c_void,
    ) -> PanError;
}
extern "C" {
    pub fn PanScionSocketWriteToViaAsync(
        conn: PanScionSocket,
        buffer: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        to: PanUDPAddr,
        path: PanPath,
        n: *mut ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
        waker: OnCompletionWaker,
        arc_conn: *mut ::std::os::raw::c_void,
    ) -> PanError;
}
extern "C" {
    pub fn PanScionSocketReadFromAsyncVia(
        conn: PanScionSocket,
        buffer: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        from: *mut PanUDPAddr,
        path: *mut PanPath,
        n: *mut ::std::os::raw::c_int,
        timeout_duration: ::std::os::raw::c_int,
        waker: OnCompletionWaker,
        arc_conn: *mut ::std::os::raw::c_void,
    ) -> PanError;
}
extern "C" {
    pub fn PanScionSocketClose(conn: PanScionSocket) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.ListenConn).SetDeadline`\n\\param[in] conn Connection to set the deadline on.\n\\param[in] t is the number milliseconds the deadline is set in the future.\n\\ingroup listen_conn"]
    pub fn PanScionSocketSetDeadline(conn: PanScionSocket, t: u32) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.ListenConn).SetReadDeadline`\n\\param[in] conn Connection to set the deadline on.\n\\param[in] t is the number milliseconds the deadline is set in the future.\n\\ingroup listen_conn"]
    pub fn PanScionSocketSetReadDeadline(conn: PanScionSocket, t: u32) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.ListenConn).SetWriteDeadline`\n\\param[in] conn Connection to set the deadline on.\n\\param[in] t is the number milliseconds the deadline is set in the future.\n\\ingroup listen_conn"]
    pub fn PanScionSocketSetWriteDeadline(conn: PanScionSocket, t: u32) -> PanError;
}
extern "C" {
    #[doc = "\\brief Open a UDP socket and listen for connections.\n\\param[in] listen is the local IP and port to listen on as a null-terminated\nstring (e.g., \"127.0.0.1:8000\").\n\\param[in] selector Reply path selector. May be a PAN_INVALID_HANDLE to use the\ndefault selector.\n\\param[out] conn The value pointed to by \\p conn receives the listening\nconnection handle if the call is successful.\n\\ingroup listen_conn\n\\return `PAN_ERR_OK` on success.\n`PAN_ERR_ADDR_SYNTAX` is the listen address has an invalid format.\n`PAN_ERR_FAILED` if binding and listening on the socket failed."]
    pub fn PanListenUDP(
        listen: *const ::std::os::raw::c_char,
        selector: PanReplySelector,
        conn: *mut PanListenConn,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.ListenConn).ReadFrom`\n\\param[in] conn Listening connection.\n\\param[in] buffer Pointer to a buffer that will receive the packet.\n\\param[in] len Size of \\p buffer in bytes.\n\\param[out] from Host from which data was received. Can be NULL to ignore.\n\\param[out] n Number of bytes read. Can be NULL to ignore.\n\\return `PAN_ERR_OK` on success.\n`PAN_ERR_DEADLINE` if the deadline was exceeded.\n`PAN_ERR_FAILED` if the operation failed.\n\\ingroup listen_conn"]
    pub fn PanListenConnReadFrom(
        conn: PanListenConn,
        buffer: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        from: *mut PanUDPAddr,
        n: *mut ::std::os::raw::c_int,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.ListenConn).ReadFrom`\n\\param[in] conn Listening connection.\n\\param[in] buffer Pointer to a buffer that will receive the packet.\n\\param[in] len Size of \\p buffer in bytes.\n\\param[out] from Host from which data was received. Can be NULL to ignore.\n\\param[out] n Number of bytes read. Can be NULL to ignore.\n\\return `PAN_ERR_OK` on success.\n`PAN_ERR_DEADLINE` if the deadline was exceeded.\n`PAN_ERR_FAILED` if the operation failed.\n\\ingroup listen_conn"]
    pub fn PanListenConnReadFromAsync(
        conn: PanListenConn,
        buffer: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        from: *mut PanUDPAddr,
        n: *mut ::std::os::raw::c_int,
        timeout_duration: ::std::os::raw::c_int,
        waker: OnCompletionWaker,
        arc_conn: *mut ::std::os::raw::c_void,
    ) -> PanError;
}
extern "C" {
    pub fn PanListenConnReadFromAsyncVia(
        conn: PanListenConn,
        buffer: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        from: *mut PanUDPAddr,
        path: *mut PanPath,
        n: *mut ::std::os::raw::c_int,
        timeout_duration: ::std::os::raw::c_int,
        waker: OnCompletionWaker,
        arc_conn: *mut ::std::os::raw::c_void,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.ListenConn).ReadFromVia`\n\\param[in] conn Listening connection.\n\\param[in] buffer Pointer to a buffer that will receive the packet.\n\\param[in] len Size of \\p buffer in bytes.\n\\param[out] from Host from which data was received. Can be NULL to ignore.\n\\param[out] path Path of the received packet. Can be NULL to ignore.\n\\param[out] n Number of bytes read. Can be NULL to ignore.\n\\return `PAN_ERR_OK` on success.\n`PAN_ERR_DEADLINE` if the deadline was exceeded.\n`PAN_ERR_FAILED` if the operation failed.\n\\ingroup listen_conn"]
    pub fn PanListenConnReadFromVia(
        conn: PanListenConn,
        buffer: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        from: *mut PanUDPAddr,
        path: *mut PanPath,
        n: *mut ::std::os::raw::c_int,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\briefWrapper for `(pan.ListenConn).WriteTo`\n\\param[in] conn Listening connection.\n\\param[in] buffer Pointer to a buffer containing the message.\n\\param[in] len Length of the message in \\p buffer in bytes.\n\\param[in] to Destination address.\n\\param[out] n Number of bytes written. Can be NULL to ignore.\n\\return `PAN_ERR_OK` on success.\n`PAN_ERR_DEADLINE` if the deadline was exceeded.\n`PAN_ERR_NO_PATH` if no path to the destination is known.\n`PAN_ERR_FAILED` if the operation failed in some other way.\n\\ingroup listen_conn"]
    pub fn PanListenConnWriteTo(
        conn: PanListenConn,
        buffer: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        to: PanUDPAddr,
        n: *mut ::std::os::raw::c_int,
    ) -> PanError;
}
extern "C" {
    pub fn PanListenConnWriteToAsync(
        conn: PanListenConn,
        buffer: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        to: PanUDPAddr,
        n: *mut ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
        waker: OnCompletionWaker,
        arc_conn: *mut ::std::os::raw::c_void,
    ) -> PanError;
}
extern "C" {
    pub fn PanListenConnWriteToViaAsync(
        conn: PanListenConn,
        buffer: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        to: PanUDPAddr,
        path: PanPath,
        n: *mut ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
        waker: OnCompletionWaker,
        arc_conn: *mut ::std::os::raw::c_void,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.ListenConn).WriteToVia`\n\\param[in] conn Listening connection.\n\\param[in] buffer Pointer to a buffer containing the message.\n\\param[in] len Length of the message in \\p buffer in bytes.\n\\param[in] to Destination address.\n\\param[in] path Path to take to the destination.\n\\param[out] n Number of bytes written. Can be NULL to ignore.\n\\return `PAN_ERR_OK` on success.\n`PAN_ERR_DEADLINE` if the deadline was exceeded.\n`PAN_ERR_FAILED` if the operation failed.\n\\ingroup listen_conn"]
    pub fn PanListenConnWriteToVia(
        conn: PanListenConn,
        buffer: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        to: PanUDPAddr,
        path: PanPath,
        n: *mut ::std::os::raw::c_int,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.ListenConn).LocalAddr`\n\\ingroup listen_conn"]
    pub fn PanListenConnLocalAddr(conn: PanListenConn) -> PanUDPAddr;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.ListenConn).SetDeadline`\n\\param[in] conn Connection to set the deadline on.\n\\param[in] t is the number milliseconds the deadline is set in the future.\n\\ingroup listen_conn"]
    pub fn PanListenConnSetDeadline(conn: PanListenConn, t: u32) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.ListenConn).SetReadDeadline`\n\\param[in] conn Connection to set the deadline on.\n\\param[in] t is the number milliseconds the deadline is set in the future.\n\\ingroup listen_conn"]
    pub fn PanListenConnSetReadDeadline(conn: PanListenConn, t: u32) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.ListenConn).SetWriteDeadline`\n\\param[in] conn Connection to set the deadline on.\n\\param[in] t is the number milliseconds the deadline is set in the future.\n\\ingroup listen_conn"]
    pub fn PanListenConnSetWriteDeadline(conn: PanListenConn, t: u32) -> PanError;
}
extern "C" {
    #[doc = "\\brief Close a listening socket. The handle must still be deleted with\nPanDeleteHandle().\n\\ingroup listen_conn"]
    pub fn PanListenConnClose(conn: PanListenConn) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `pan.DialUDP`\n\\param[in] local is the local IP and port as string. Can be NULL to automatically\nchoose.\n\\param[in] remote is the SCION address of the remote host.\n\\param[in] policy Path policy. May be a PAN_INVALID_HANDLE to use the default\npolicy.\n\\param[in] selector Path selector. May be a PAN_INVALID_HANDLE to use the\ndefault selector.\n\\param[out] conn The value pointed to by \\p conn receives the connection handle\nif the call is successful.\n\\return `PAN_ERR_OK` on success.\n`PAN_ERR_ADDR_SYNTAX` is the local address has an invalid format.\n`PAN_ERR_FAILED` if dialing failed.\n\\ingroup conn"]
    pub fn PanDialUDP(
        local: *const ::std::os::raw::c_char,
        remote: PanUDPAddr,
        policy: PanPolicy,
        selector: PanSelector,
        conn: *mut PanConn,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.Conn).Read`\n\\param[in] conn Connection\n\\param[in] buffer Pointer to a buffer that will receive the packet.\n\\param[in] len Size of \\p buffer in bytes.\n\\param[out] n Number of bytes read. Can be NULL to ignore.\n\\return `PAN_ERR_OK` on success.\n`PAN_ERR_DEADLINE` if the deadline was exceeded.\n`PAN_ERR_FAILED` if the operation failed.\n\\ingroup conn"]
    pub fn PanConnRead(
        conn: PanConn,
        buffer: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.Conn).ReadVia`\n\\param[in] conn Connection\n\\param[in] buffer Pointer to a buffer that will receive the packet.\n\\param[in] len Size of \\p buffer in bytes.\n\\param[out] path Path of the received packet. Can be NULL to ignore.\n\\param[out] n Number of bytes read. Can be NULL to ignore.\n\\return `PAN_ERR_OK` on success.\n`PAN_ERR_DEADLINE` if the deadline was exceeded.\n`PAN_ERR_FAILED` if the operation failed.\n\\ingroup conn"]
    pub fn PanConnReadVia(
        conn: PanConn,
        buffer: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        path: *mut PanPath,
        n: *mut ::std::os::raw::c_int,
    ) -> PanError;
}
extern "C" {
    pub fn PanConnReadViaAsync(
        conn: PanConn,
        buffer: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        path: *mut PanPath,
        n: *mut ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
        waker: OnCompletionWaker,
        arc_conn: *mut ::std::os::raw::c_void,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.Conn).Write`\n\\param[in] conn Connection\n\\param[in] buffer Pointer to a buffer containing the message.\n\\param[in] len Length of the message in \\p buffer in bytes.\n\\param[out] n Number of bytes written. Can be NULL to ignore.\n\\return `PAN_ERR_OK` on success.\n`PAN_ERR_DEADLINE` if the deadline was exceeded.\n`PAN_ERR_NO_PATH` if no path to the destination is known.\n`PAN_ERR_FAILED` if the operation failed in some other way.\n\\ingroup conn"]
    pub fn PanConnWrite(
        conn: PanListenConn,
        buffer: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
    ) -> PanError;
}
extern "C" {
    pub fn PanConnWriteAsync(
        conn: PanListenConn,
        buffer: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
        waker: OnCompletionWaker,
        arc_conn: *mut ::std::os::raw::c_void,
    ) -> PanError;
}
extern "C" {
    pub fn GetLocalIA(do_panic: GoUint8) -> GoUint64;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.Conn).WriteVia`\n\\param[in] conn Connection\n\\param[in] buffer Pointer to a buffer containing the message.\n\\param[in] len Length of the message in \\p buffer in bytes.\n\\param[in] path Path to take to the destination.\n\\param[out] n Number of bytes written. Can be NULL to ignore.\n\\return `PAN_ERR_OK` on success.\n`PAN_ERR_DEADLINE` if the deadline was exceeded.\n`PAN_ERR_FAILED` if the operation failed.\n\\ingroup conn"]
    pub fn PanConnWriteVia(
        conn: PanListenConn,
        buffer: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        path: PanPath,
        n: *mut ::std::os::raw::c_int,
    ) -> PanError;
}
extern "C" {
    pub fn PanConnWriteViaAsync(
        conn: PanListenConn,
        buffer: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        path: PanPath,
        n: *mut ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
        waker: OnCompletionWaker,
        arc_conn: *mut ::std::os::raw::c_void,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for (pan.Conn).LocalAddr\n\\ingroup conn"]
    pub fn PanConnLocalAddr(conn: PanConn) -> PanUDPAddr;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.Conn).RemoteAddr`\n\\ingroup conn"]
    pub fn PanConnRemoteAddr(conn: PanConn) -> PanUDPAddr;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.Conn).SetDeadline`\n\\param[in] conn Connection to set the deadline on.\n\\param[in] t is the number milliseconds the deadline is set in the future.\n\\ingroup conn"]
    pub fn PanConnSetDeadline(conn: PanConn, t: u32) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.Conn).SetReadDeadline`\n\\param[in] conn Connection to set the deadline on.\n\\param[in] t is the number milliseconds the deadline is set in the future.\n\\ingroup conn"]
    pub fn PanConnSetReadDeadline(conn: PanConn, t: u32) -> PanError;
}
extern "C" {
    #[doc = "\\brief Wrapper for `(pan.Conn).SetWriteDeadline`\n\\param[in] conn Connection to set the deadline on.\n\\param[in] t is the number milliseconds the deadline is set in the future.\n\\ingroup conn"]
    pub fn PanConnSetWriteDeadline(conn: PanConn, t: u32) -> PanError;
}
extern "C" {
    #[doc = "\\brief Close a connection. The handle must still be deleted with\nPanDeleteHandle().\n\\ingroup conn"]
    pub fn PanConnClose(conn: PanConn) -> PanError;
}
extern "C" {
    #[doc = "\\brief Open a Unix datagram socket at `listen_addr` as proxy for `pan_conn` or scion_socket (any SocketLike type).\n\\attention deprecated in favour of PanNewListenSockAdapter2\nReason:\tconversion of C to Go string with func C.GoString(p *_Ctype_char) string has been repeatedly found to be unreliable and cause bugs.\nAll packets received by `pan_conn` are forwarded from `listen_addr` to `client_addr`.\nAll packets received from the Unix socket are forwarded to `pan_conn`.\nThe SCION address of the source or destination is prepended to the payload in a\n32 byte header:\n\\verbatim\nbyte 0       1       2       3       4       5       6       7\n+-------+-------+-------+-------+-------+-------+-------+-------+\n0 |    ISD (BE)   |                     ASN (BE)                  |\n+-------+-------+-------+-------+-------+-------+-------+-------+\n8 |    Host Addr. Length (LE)     |                               |\n+-------+-------+-------+-------+                               |\n16 |                         Host Address (BE)                     |\n+                               +-------+-------+-------+-------+\n24 |                               | UDP Port (LE) |       0       |\n+-------+-------+-------+-------+-------+-------+-------+-------+\nBE = big-endian\nLE = little-endian\n\\endverbatim\n\n\\param[in] pan_conn Listening PAN connection or ScionSocket (any type that implements SocketLike).\n\\param[in] listen_addr Local address of the socket in the file system.\nOn the 'FFI caller' side a unix domain socket must have been constructed an bound to this address\nbefore the adapter is constructed.\n\\param[in] client_addr Address of the other end of the connection in the C part\nof the program.\n\\param[out] adapter Socket adapter object.\n\\ingroup adapter"]
    pub fn PanNewListenSockAdapter(
        pan_conn: PanListenConn,
        listen_addr: *const ::std::os::raw::c_char,
        client_addr: *const ::std::os::raw::c_char,
        adapter: *mut PanListenSockAdapter,
    ) -> PanError;
}
extern "C" {
    pub fn PanNewListenSockAdapter2(
        pan_conn: PanListenConn,
        listen_addr: *const ::std::os::raw::c_char,
        len1: ::std::os::raw::c_int,
        client_addr: *const ::std::os::raw::c_char,
        len2: ::std::os::raw::c_int,
        adapter: *mut PanListenSockAdapter,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Close the Unix domain socket **and the PAN connection**.\n\\ingroup adapter"]
    pub fn PanListenSockAdapterClose(adapter: PanListenSockAdapter) -> PanError;
}
extern "C" {
    #[doc = "\\brief Open a Unix datagram socket at `listen_addr` as proxy for `pan_conn`.\n\nAll packets received by pan_conn are forwarded from `listen_addr` to `client_addr`.\nAll packets received from the unix socket are forwarded to `pan_conn`.\n\n\\param[in] pan_conn Connected PAN connection.\n\\param[in] listen_addr Local address of the unix socket in the file system.\n\\param[in] client_addr Address of the other end of the connection in the C part\nof the program.\n\\param[out] adapter Socket adapter object.\n\\ingroup adapter"]
    pub fn PanNewConnSockAdapter(
        pan_conn: PanConn,
        listen_addr: *const ::std::os::raw::c_char,
        client_addr: *const ::std::os::raw::c_char,
        adapter: *mut PanConnSockAdapter,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Close the Unix domain socket **and the PAN connection**.\n\\ingroup adapter"]
    pub fn PanConnSockAdapterClose(adapter: PanConnSockAdapter) -> PanError;
}
extern "C" {
    #[doc = "\\brief Open a Unix stream socket at `listen_addr` as proxy for `pan_conn` or 'scion_socket'(any SocketLike).\n\nBehaves identical to `PanNewListenSockAdapter` except that a stream socket is\nused instead of a datagram socket. Packet borders in the stream are determined\nby prepending a four byte message length (little endian) in front of every\npacket sent or received on the Unix socket.\n\nWhen initially created, the socket will listens for and accept exactly one\nconnection.\n\nThe stream variants of the socket adapters are intended for systems lacking\nsupport for Unix datagram sockets, e.g., Windows. A more native solution on\nWindows might be named pipes, however they have a very different API from\nsockets.\n\n\\param[in] pan_conn Listening PAN connection.\n\\param[in] listen_addr Local address of the socket in the file system.\n\\param[out] adapter Socket adapter object.\n\\ingroup adapter"]
    pub fn PanNewListenSSockAdapter(
        pan_conn: PanListenConn,
        listen_addr: *const ::std::os::raw::c_char,
        adapter: *mut PanListenSSockAdapter,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Close the Unix domain socket **and the PAN connection**.\n\\ingroup adapter"]
    pub fn PanListenSSockAdapterClose(adapter: PanListenSSockAdapter) -> PanError;
}
extern "C" {
    #[doc = "\\brief Open a Unix stream socket at `listen_addr` as proxy for `pan_conn`.\n\nBehaves identical to `PanNewConnSockAdapter` except that a stream socket is\nused instead of a datagram socket. Packet borders in the stream are determined\nby prepending a four byte message length (little endian) in front of every\npacket sent or received on the Unix socket.\n\nWhen initially created, the socket will listens for and accept exactly one\nconnection.\n\nThe stream variants of the socket adapters are intended for systems lacking\nsupport for Unix datagram sockets, e.g., Windows. A more native solution on\nWindows might be named pipes, however they have a very different API from\nsockets.\n\n\\param[in] pan_conn Connected PAN connection.\n\\param[in] listen_addr Local address of the Unix socket in the file system.\n\\param[out] adapter Socket adapter object.\n\\ingroup adapter"]
    pub fn PanNewConnSSockAdapter(
        pan_conn: PanConn,
        listen_addr: *const ::std::os::raw::c_char,
        adapter: *mut PanConnSSockAdapter,
    ) -> PanError;
}
extern "C" {
    #[doc = "\\brief Close the Unix domain socket **and the PAN connection**.\n\\ingroup adapter"]
    pub fn PanConnSSockAdapterClose(adapter: PanConnSSockAdapter) -> PanError;
}
